title: Webpack学习笔记（1）
tags:
  - 前端
categories:
  - web
author: 乔丁
date: 2018-10-15 21:09:09
description: 入门了解
photos: http://p7wm7amg2.bkt.clouddn.com/webpack.png
---

## 前端发展

### 模块化
之前开发网页需要通过命名空间的方式来组织代码，例如jQuery把API放在window.$下，在加载完jQuery后其他模块通过window.$去使用jQuery。会有以下问题：
 - 命名空间可能会冲突，都放在了window.$下
 - 无法合理地管理项目的依赖和版本
 - 无法方便地控制依赖的加载顺序
当项目较大时便难以维护，需要模块化思想来组织代码

#### CommonJS
通过require方法同步地加载依赖的其他模块，通过module.exports导出需要暴漏的接口
```javascript
const moduleA = require('./moduleA');
module.exports = moduleA.someFunc;
```
优点：
- 代码可复用于node环境并运行
- npm发布的很多第三方模块都采用了CommonJS规范
缺点：
- 无法直接在浏览器环境运行，必须通过工具转化为标准的es5
> commonjs还分为1和2，区别在于1只能通过export.xx = xx的方式导出，commonjs2在1的基础上加入了module.export = xx的方式，一般commonjs通常指commonjs2

#### AMD
AMD是异步的模块化规范，AMD主要是解决浏览器环境模块化的问题，最具代表性的是requirejs。
```javascript
// 定义一个模块
defined('module', ['dep'], function(dep){
  return exports;
})

//导入和使用
require(['module'], function(module){
});
```
AMD的优点在于
- 可在不转换代码的情况下直接在浏览器中运行
- 可以异步加载依赖
- 可以并行加载多个依赖
- 也可在node环境下运行

缺点在于js运行环境没有原生支持它，需要先导入实现了AMD的库后才能正常使用

#### ES6模块化
es6模块化是ECMA提出的js模块化规范，在语言层面上实现了模块化。浏览器和node都支持。
```javascript
// 导入
import { readFile } from 'fs'
import React from 'react'

// 导出
export function hello(){};
export default {};
```

es6模块化规范虽然是终极模块化方案，缺点在于目前无法直接运行在大部分js环境下，必须转成es5后才能正常运行

#### 样式文件的模块化
在scss中，把一些常用的样式片段放进一个通用的样式文件里，在另一个文件里通过import语句导入使用这些样式片段。

#### 框架中的应用
web应用庞大复杂时，采用直接操作DOM的方式去开发将会变得复杂和难以维护。
##### react
jsx语法需要转换才可在js引擎里运行。
##### vue
vue可以把html模板，js逻辑，css样式都写在一个文件里
##### angular2
angular推崇ts语言去开发应用，并且可以通过注释的语法描述组件的属性。

#### 新语言
- ES6。是js语言的下一代标准。在语言层面为js引入了很多新语法和API。但是并不是全部支持，babel可以讲es6转换为es5
- typescript。ts是js的一个超集，微软开发，除了支持es6功能外还提供了静态类检查。将 TypeScript 用于开发大型项目时，其优点才能体现出来，因为大型项目由多个模块组合而成，不同模块可能又由不同人编写，在对接不同模块时静态类型检查会在编译阶段找出可能存在的问题。 TypeScript 的缺点在于语法相对于 JavaScript 更加啰嗦，并且无法直接运行在浏览器或 Node.js 环境下。
- flow。也是js的一个超集，主要是提供了静态类型检查，和ts相似但是更灵活。可以在需要的地方加上类型检查。
- scss。他是一种css预处理器，基本思想是用和css相似的编程语言写完后再编译成正常的css文件。
新语言提升编码效率，但是必须转换后才可在浏览器下运行。

构建其实是工程化，自动化思想在前端开发中的提现，把一系列流程用代码去实现，让代码自动化地执行这一系列复杂的流程。

##### grunt
优点:
- 灵活，它只负责执行你定义的任务
- 大量的可复用插件封装好了常见构建任务

缺点：集成度不高，需要写很多配置后才可使用，无法做到开箱及用。

##### gulp
gulp是一个基于流的自动化构建工具。除了可以管理和执行任务，还支持监听文件，读写文件。gulp被设计的很简单，通过一下五个方法就可以胜任所有构建场景：
- 通过 gulp.task 注册一个任务；
- 通过 gulp.run 执行任务；
- 通过 gulp.watch 监听文件变化；
- 通过 gulp.src 读取文件；
- 通过 gulp.dest 写文件。

gulp最大的特点是引入了流的概念，同时提供了一系列常用都插件去处理流，流可以在插件之间传递。
优点：好用，灵活。
缺点：集成度低，要写很多配置后才可以使用，无法做到开箱即用。

可以将Gulp 看作 Grunt 的加强版。相对于 Grunt，Gulp增加了监听文件、读写文件、流式处理的功能。


##### 重点来了Webpack
webpack是一个大包模块化js工具，在webpack中一切文件皆模块，通过loader转换文件，通过plugins注入钩子，最后输出多个模块组合成的文件。webpack专注于构建模块化项目。

一切文件：js，css，scss，图片，模板，在webpack眼中都是模块，这样的好处就是能清晰的描述出各个模块之间的依赖关系，以方便webpack√模块进行组合和打包。通过webpack对模块的处理，最终会输出浏览器能用的静态文件。

大致用法：
```javascrit
module.exports = {
  // 所有模块的入口，Webpack 从入口开始递归解析出所有依赖的模块
  entry: './app.js',
  output: {
    // 把入口所依赖的所有模块打包成一个文件 bundle.js 输出 
    filename: 'bundle.js'
  }
}
```
优点：
- 专注于处理模块化的项目，能做到开箱即用一步到位；
- 通过 Plugin 扩展，完整好用又不失灵活；
- 使用场景不仅限于 Web 开发；
- 社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展；
- 良好的开发体验。

缺点：只能用于采用模块化开发的项目

#### 为什么选择webpack
上面介绍的构建工具是按照它们诞生的时间排序的，它们是时代的产物，侧面反映出 Web 开发的发展趋势如下：

1.在 Npm Script 和 Grunt 时代，Web 开发要做的事情变多，流程复杂，自动化思想被引入，用于简化流程；

2.在 Gulp 时代开始出现一些新语言用于提高开发效率，流式处理思想的出现是为了简化文件转换的流程，例如将 ES6 转换成 ES5。
在 Webpack 时代由于单页应用的流行，一个网页的功能和实现代码变得庞大，Web 开发向模块化改进。

3.这些构建工具都有各自的定位和专注点，它们之间既可以单独地完成任务，也可以相互搭配起来弥补各自的不足。 在了解这些常见的构建工具后，你需要根据自己的需求去判断应该如何选择和搭配它们才能更好地完成自己的需求。

经过多年的发展， Webpack 已经成为构建工具中的首选，这是有原因的：

- 大多数团队在开发新项目时会采用紧跟时代的技术，这些技术几乎都会采用“模块化+新语言+新框架”，Webpack 可以为这些新项目提供一站式的解决方案；
- Webpack 有良好的生态链和维护团队，能提供良好的开发体验和保证质量；
- Webpack 被全世界的大量 Web 开发者使用和验证，能找到各个层面所需的教程和经验分享。